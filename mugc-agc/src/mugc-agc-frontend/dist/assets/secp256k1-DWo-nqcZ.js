import{H as v,a as A,t as C,b as w,c as S,w as G,r as M,d as N,F as U,m as y,p as o,s as W}from"./index-CLFOVsZv.js";class L extends v{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,A(t);const i=C(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,f=new Uint8Array(r);f.set(i.length>r?t.create().update(i).digest():i);for(let n=0;n<f.length;n++)f[n]^=54;this.iHash.update(f),this.oHash=t.create();for(let n=0;n<f.length;n++)f[n]^=106;this.oHash.update(f),f.fill(0)}update(t){return w(this),this.iHash.update(t),this}digestInto(t){w(this),S(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:i,finished:r,destroyed:f,blockLen:n,outputLen:h}=this;return t=t,t.finished=r,t.destroyed=f,t.blockLen=n,t.outputLen=h,t.oHash=e._cloneInto(t.oHash),t.iHash=i._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const m=(s,t,e)=>new L(s,t).update(e).digest();m.create=(s,t)=>new L(s,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function z(s){return{hash:s,hmac:(t,...e)=>m(s,t,N(...e)),randomBytes:M}}function D(s,t){const e=i=>G({...s,...z(i)});return{...e(t),create:e}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),_=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),J=BigInt(1),p=BigInt(2),k=(s,t)=>(s+t/p)/t;function K(s){const t=P,e=BigInt(3),i=BigInt(6),r=BigInt(11),f=BigInt(22),n=BigInt(23),h=BigInt(44),d=BigInt(88),c=s*s*s%t,a=c*c*s%t,u=o(a,e,t)*a%t,g=o(u,e,t)*a%t,B=o(g,p,t)*c%t,b=o(B,r,t)*B%t,l=o(b,f,t)*b%t,H=o(l,h,t)*l%t,q=o(H,d,t)*H%t,E=o(q,h,t)*l%t,F=o(E,e,t)*a%t,O=o(F,n,t)*b%t,j=o(O,i,t)*c%t,x=o(j,p,t);if(!I.eql(I.sqr(x),s))throw new Error("Cannot find square root");return x}const I=U(P,void 0,void 0,{sqrt:K}),Q=D({a:BigInt(0),b:BigInt(7),Fp:I,n:_,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:s=>{const t=_,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),i=-J*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),r=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),f=e,n=BigInt("0x100000000000000000000000000000000"),h=k(f*s,t),d=k(-i*s,t);let c=y(s-h*e-d*r,t),a=y(-h*i-d*f,t);const u=c>n,g=a>n;if(u&&(c=t-c),g&&(a=t-a),c>n||a>n)throw new Error("splitScalar: Endomorphism failed, k="+s);return{k1neg:u,k1:c,k2neg:g,k2:a}}}},W);BigInt(0);Q.ProjectivePoint;export{Q as secp256k1};
